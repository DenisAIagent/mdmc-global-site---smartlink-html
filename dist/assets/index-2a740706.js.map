{"version":3,"file":"index-2a740706.js","sources":["../../node_modules/@tanstack/query-core/build/modern/queriesObserver.js","../../node_modules/@tanstack/query-core/build/modern/infiniteQueryObserver.js","../../node_modules/@tanstack/query-core/build/modern/mutationObserver.js","../../node_modules/@tanstack/query-core/build/modern/hydration.js","../../node_modules/@tanstack/query-core/build/modern/streamedQuery.js","../../node_modules/@tanstack/query-core/build/modern/types.js","../../node_modules/@tanstack/react-query/build/modern/useQueries.js","../../node_modules/@tanstack/react-query/build/modern/useSuspenseQuery.js","../../node_modules/@tanstack/react-query/build/modern/useSuspenseInfiniteQuery.js","../../node_modules/@tanstack/react-query/build/modern/useSuspenseQueries.js","../../node_modules/@tanstack/react-query/build/modern/usePrefetchQuery.js","../../node_modules/@tanstack/react-query/build/modern/usePrefetchInfiniteQuery.js","../../node_modules/@tanstack/react-query/build/modern/queryOptions.js","../../node_modules/@tanstack/react-query/build/modern/infiniteQueryOptions.js","../../node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js","../../node_modules/@tanstack/react-query/build/modern/useIsFetching.js","../../node_modules/@tanstack/react-query/build/modern/useMutationState.js","../../node_modules/@tanstack/react-query/build/modern/useMutation.js","../../node_modules/@tanstack/react-query/build/modern/mutationOptions.js","../../node_modules/@tanstack/react-query/build/modern/useInfiniteQuery.js"],"sourcesContent":["// src/queriesObserver.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { QueryObserver } from \"./queryObserver.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { replaceEqualDeep } from \"./utils.js\";\nfunction difference(array1, array2) {\n  const excludeSet = new Set(array2);\n  return array1.filter((x) => !excludeSet.has(x));\n}\nfunction replaceAt(array, index, value) {\n  const copy = array.slice(0);\n  copy[index] = value;\n  return copy;\n}\nvar QueriesObserver = class extends Subscribable {\n  #client;\n  #result;\n  #queries;\n  #options;\n  #observers;\n  #combinedResult;\n  #lastCombine;\n  #lastResult;\n  #observerMatches = [];\n  constructor(client, queries, options) {\n    super();\n    this.#client = client;\n    this.#options = options;\n    this.#queries = [];\n    this.#observers = [];\n    this.#result = [];\n    this.setQueries(queries);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      this.#observers.forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result);\n        });\n      });\n    }\n  }\n  onUnsubscribe() {\n    if (!this.listeners.size) {\n      this.destroy();\n    }\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */ new Set();\n    this.#observers.forEach((observer) => {\n      observer.destroy();\n    });\n  }\n  setQueries(queries, options) {\n    this.#queries = queries;\n    this.#options = options;\n    if (process.env.NODE_ENV !== \"production\") {\n      const queryHashes = queries.map(\n        (query) => this.#client.defaultQueryOptions(query).queryHash\n      );\n      if (new Set(queryHashes).size !== queryHashes.length) {\n        console.warn(\n          \"[QueriesObserver]: Duplicate Queries found. This might result in unexpected behavior.\"\n        );\n      }\n    }\n    notifyManager.batch(() => {\n      const prevObservers = this.#observers;\n      const newObserverMatches = this.#findMatchingObservers(this.#queries);\n      this.#observerMatches = newObserverMatches;\n      newObserverMatches.forEach(\n        (match) => match.observer.setOptions(match.defaultedQueryOptions)\n      );\n      const newObservers = newObserverMatches.map((match) => match.observer);\n      const newResult = newObservers.map(\n        (observer) => observer.getCurrentResult()\n      );\n      const hasIndexChange = newObservers.some(\n        (observer, index) => observer !== prevObservers[index]\n      );\n      if (prevObservers.length === newObservers.length && !hasIndexChange) {\n        return;\n      }\n      this.#observers = newObservers;\n      this.#result = newResult;\n      if (!this.hasListeners()) {\n        return;\n      }\n      difference(prevObservers, newObservers).forEach((observer) => {\n        observer.destroy();\n      });\n      difference(newObservers, prevObservers).forEach((observer) => {\n        observer.subscribe((result) => {\n          this.#onUpdate(observer, result);\n        });\n      });\n      this.#notify();\n    });\n  }\n  getCurrentResult() {\n    return this.#result;\n  }\n  getQueries() {\n    return this.#observers.map((observer) => observer.getCurrentQuery());\n  }\n  getObservers() {\n    return this.#observers;\n  }\n  getOptimisticResult(queries, combine) {\n    const matches = this.#findMatchingObservers(queries);\n    const result = matches.map(\n      (match) => match.observer.getOptimisticResult(match.defaultedQueryOptions)\n    );\n    return [\n      result,\n      (r) => {\n        return this.#combineResult(r ?? result, combine);\n      },\n      () => {\n        return this.#trackResult(result, matches);\n      }\n    ];\n  }\n  #trackResult(result, matches) {\n    return matches.map((match, index) => {\n      const observerResult = result[index];\n      return !match.defaultedQueryOptions.notifyOnChangeProps ? match.observer.trackResult(observerResult, (accessedProp) => {\n        matches.forEach((m) => {\n          m.observer.trackProp(accessedProp);\n        });\n      }) : observerResult;\n    });\n  }\n  #combineResult(input, combine) {\n    if (combine) {\n      if (!this.#combinedResult || this.#result !== this.#lastResult || combine !== this.#lastCombine) {\n        this.#lastCombine = combine;\n        this.#lastResult = this.#result;\n        this.#combinedResult = replaceEqualDeep(\n          this.#combinedResult,\n          combine(input)\n        );\n      }\n      return this.#combinedResult;\n    }\n    return input;\n  }\n  #findMatchingObservers(queries) {\n    const prevObserversMap = new Map(\n      this.#observers.map((observer) => [observer.options.queryHash, observer])\n    );\n    const observers = [];\n    queries.forEach((options) => {\n      const defaultedOptions = this.#client.defaultQueryOptions(options);\n      const match = prevObserversMap.get(defaultedOptions.queryHash);\n      if (match) {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: match\n        });\n      } else {\n        observers.push({\n          defaultedQueryOptions: defaultedOptions,\n          observer: new QueryObserver(this.#client, defaultedOptions)\n        });\n      }\n    });\n    return observers;\n  }\n  #onUpdate(observer, result) {\n    const index = this.#observers.indexOf(observer);\n    if (index !== -1) {\n      this.#result = replaceAt(this.#result, index, result);\n      this.#notify();\n    }\n  }\n  #notify() {\n    if (this.hasListeners()) {\n      const previousResult = this.#combinedResult;\n      const newTracked = this.#trackResult(this.#result, this.#observerMatches);\n      const newResult = this.#combineResult(newTracked, this.#options?.combine);\n      if (previousResult !== newResult) {\n        notifyManager.batch(() => {\n          this.listeners.forEach((listener) => {\n            listener(this.#result);\n          });\n        });\n      }\n    }\n  }\n};\nexport {\n  QueriesObserver\n};\n//# sourceMappingURL=queriesObserver.js.map","// src/infiniteQueryObserver.ts\nimport { QueryObserver } from \"./queryObserver.js\";\nimport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n} from \"./infiniteQueryBehavior.js\";\nvar InfiniteQueryObserver = class extends QueryObserver {\n  constructor(client, options) {\n    super(client, options);\n  }\n  bindMethods() {\n    super.bindMethods();\n    this.fetchNextPage = this.fetchNextPage.bind(this);\n    this.fetchPreviousPage = this.fetchPreviousPage.bind(this);\n  }\n  setOptions(options) {\n    super.setOptions({\n      ...options,\n      behavior: infiniteQueryBehavior()\n    });\n  }\n  getOptimisticResult(options) {\n    options.behavior = infiniteQueryBehavior();\n    return super.getOptimisticResult(options);\n  }\n  fetchNextPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"forward\" }\n      }\n    });\n  }\n  fetchPreviousPage(options) {\n    return this.fetch({\n      ...options,\n      meta: {\n        fetchMore: { direction: \"backward\" }\n      }\n    });\n  }\n  createResult(query, options) {\n    const { state } = query;\n    const parentResult = super.createResult(query, options);\n    const { isFetching, isRefetching, isError, isRefetchError } = parentResult;\n    const fetchDirection = state.fetchMeta?.fetchMore?.direction;\n    const isFetchNextPageError = isError && fetchDirection === \"forward\";\n    const isFetchingNextPage = isFetching && fetchDirection === \"forward\";\n    const isFetchPreviousPageError = isError && fetchDirection === \"backward\";\n    const isFetchingPreviousPage = isFetching && fetchDirection === \"backward\";\n    const result = {\n      ...parentResult,\n      fetchNextPage: this.fetchNextPage,\n      fetchPreviousPage: this.fetchPreviousPage,\n      hasNextPage: hasNextPage(options, state.data),\n      hasPreviousPage: hasPreviousPage(options, state.data),\n      isFetchNextPageError,\n      isFetchingNextPage,\n      isFetchPreviousPageError,\n      isFetchingPreviousPage,\n      isRefetchError: isRefetchError && !isFetchNextPageError && !isFetchPreviousPageError,\n      isRefetching: isRefetching && !isFetchingNextPage && !isFetchingPreviousPage\n    };\n    return result;\n  }\n};\nexport {\n  InfiniteQueryObserver\n};\n//# sourceMappingURL=infiniteQueryObserver.js.map","// src/mutationObserver.ts\nimport { getDefaultState } from \"./mutation.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { hashKey, shallowEqualObjects } from \"./utils.js\";\nvar MutationObserver = class extends Subscribable {\n  #client;\n  #currentResult = void 0;\n  #currentMutation;\n  #mutateOptions;\n  constructor(client, options) {\n    super();\n    this.#client = client;\n    this.setOptions(options);\n    this.bindMethods();\n    this.#updateResult();\n  }\n  bindMethods() {\n    this.mutate = this.mutate.bind(this);\n    this.reset = this.reset.bind(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    this.options = this.#client.defaultMutationOptions(options);\n    if (!shallowEqualObjects(this.options, prevOptions)) {\n      this.#client.getMutationCache().notify({\n        type: \"observerOptionsUpdated\",\n        mutation: this.#currentMutation,\n        observer: this\n      });\n    }\n    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {\n      this.reset();\n    } else if (this.#currentMutation?.state.status === \"pending\") {\n      this.#currentMutation.setOptions(this.options);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.#currentMutation?.removeObserver(this);\n    }\n  }\n  onMutationUpdate(action) {\n    this.#updateResult();\n    this.#notify(action);\n  }\n  getCurrentResult() {\n    return this.#currentResult;\n  }\n  reset() {\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = void 0;\n    this.#updateResult();\n    this.#notify();\n  }\n  mutate(variables, options) {\n    this.#mutateOptions = options;\n    this.#currentMutation?.removeObserver(this);\n    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);\n    this.#currentMutation.addObserver(this);\n    return this.#currentMutation.execute(variables);\n  }\n  #updateResult() {\n    const state = this.#currentMutation?.state ?? getDefaultState();\n    this.#currentResult = {\n      ...state,\n      isPending: state.status === \"pending\",\n      isSuccess: state.status === \"success\",\n      isError: state.status === \"error\",\n      isIdle: state.status === \"idle\",\n      mutate: this.mutate,\n      reset: this.reset\n    };\n  }\n  #notify(action) {\n    notifyManager.batch(() => {\n      if (this.#mutateOptions && this.hasListeners()) {\n        const variables = this.#currentResult.variables;\n        const context = this.#currentResult.context;\n        if (action?.type === \"success\") {\n          this.#mutateOptions.onSuccess?.(action.data, variables, context);\n          this.#mutateOptions.onSettled?.(action.data, null, variables, context);\n        } else if (action?.type === \"error\") {\n          this.#mutateOptions.onError?.(action.error, variables, context);\n          this.#mutateOptions.onSettled?.(\n            void 0,\n            action.error,\n            variables,\n            context\n          );\n        }\n      }\n      this.listeners.forEach((listener) => {\n        listener(this.#currentResult);\n      });\n    });\n  }\n};\nexport {\n  MutationObserver\n};\n//# sourceMappingURL=mutationObserver.js.map","// src/hydration.ts\nimport { tryResolveSync } from \"./thenable.js\";\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return {\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state,\n    ...mutation.options.scope && { scope: mutation.options.scope },\n    ...mutation.meta && { meta: mutation.meta }\n  };\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  return {\n    dehydratedAt: Date.now(),\n    state: {\n      ...query.state,\n      ...query.state.data !== void 0 && {\n        data: serializeData(query.state.data)\n      }\n    },\n    queryKey: query.queryKey,\n    queryHash: query.queryHash,\n    ...query.state.status === \"pending\" && {\n      promise: query.promise?.then(serializeData).catch((error) => {\n        if (!shouldRedactErrors(error)) {\n          return Promise.reject(error);\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.error(\n            `A query that was dehydrated as pending ended up rejecting. [${query.queryHash}]: ${error}; The error will be redacted in production builds`\n          );\n        }\n        return Promise.reject(new Error(\"redacted\"));\n      })\n    },\n    ...query.meta && { meta: query.meta }\n  };\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client, options = {}) {\n  const filterMutation = options.shouldDehydrateMutation ?? client.getDefaultOptions().dehydrate?.shouldDehydrateMutation ?? defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(\n    (mutation) => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []\n  );\n  const filterQuery = options.shouldDehydrateQuery ?? client.getDefaultOptions().dehydrate?.shouldDehydrateQuery ?? defaultShouldDehydrateQuery;\n  const shouldRedactErrors = options.shouldRedactErrors ?? client.getDefaultOptions().dehydrate?.shouldRedactErrors ?? defaultShouldRedactErrors;\n  const serializeData = options.serializeData ?? client.getDefaultOptions().dehydrate?.serializeData ?? defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(\n    (query) => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []\n  );\n  return { mutations, queries };\n}\nfunction hydrate(client, dehydratedState, options) {\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = options?.defaultOptions?.deserializeData ?? client.getDefaultOptions().hydrate?.deserializeData ?? defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(({ state, ...mutationOptions }) => {\n    mutationCache.build(\n      client,\n      {\n        ...client.getDefaultOptions().hydrate?.mutations,\n        ...options?.defaultOptions?.mutations,\n        ...mutationOptions\n      },\n      state\n    );\n  });\n  queries.forEach(\n    ({ queryKey, state, queryHash, meta, promise, dehydratedAt }) => {\n      const syncData = promise ? tryResolveSync(promise) : void 0;\n      const rawData = state.data === void 0 ? syncData?.data : state.data;\n      const data = rawData === void 0 ? rawData : deserializeData(rawData);\n      let query = queryCache.get(queryHash);\n      const existingQueryIsPending = query?.state.status === \"pending\";\n      const existingQueryIsFetching = query?.state.fetchStatus === \"fetching\";\n      if (query) {\n        const hasNewerSyncData = syncData && // We only need this undefined check to handle older dehydration\n        // payloads that might not have dehydratedAt\n        dehydratedAt !== void 0 && dehydratedAt > query.state.dataUpdatedAt;\n        if (state.dataUpdatedAt > query.state.dataUpdatedAt || hasNewerSyncData) {\n          const { fetchStatus: _ignored, ...serializedState } = state;\n          query.setState({\n            ...serializedState,\n            data\n          });\n        }\n      } else {\n        query = queryCache.build(\n          client,\n          {\n            ...client.getDefaultOptions().hydrate?.queries,\n            ...options?.defaultOptions?.queries,\n            queryKey,\n            queryHash,\n            meta\n          },\n          // Reset fetch status to idle to avoid\n          // query being stuck in fetching state upon hydration\n          {\n            ...state,\n            data,\n            fetchStatus: \"idle\",\n            status: data !== void 0 ? \"success\" : state.status\n          }\n        );\n      }\n      if (promise && !existingQueryIsPending && !existingQueryIsFetching && // Only hydrate if dehydration is newer than any existing data,\n      // this is always true for new queries\n      (dehydratedAt === void 0 || dehydratedAt > query.state.dataUpdatedAt)) {\n        void query.fetch(void 0, {\n          // RSC transformed promises are not thenable\n          initialPromise: Promise.resolve(promise).then(deserializeData)\n        });\n      }\n    }\n  );\n}\nexport {\n  defaultShouldDehydrateMutation,\n  defaultShouldDehydrateQuery,\n  dehydrate,\n  hydrate\n};\n//# sourceMappingURL=hydration.js.map","// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery({\n  queryFn,\n  refetchMode = \"reset\",\n  maxChunks\n}) {\n  return async (context) => {\n    const query = context.client.getQueryCache().find({ queryKey: context.queryKey, exact: true });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = [];\n    const stream = await queryFn(context);\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break;\n      }\n      if (!isRefetch || refetchMode !== \"replace\") {\n        context.client.setQueryData(\n          context.queryKey,\n          (prev = []) => {\n            return addToEnd(prev, chunk, maxChunks);\n          }\n        );\n      }\n      result = addToEnd(result, chunk, maxChunks);\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return context.client.getQueryData(context.queryKey);\n  };\n}\nexport {\n  streamedQuery\n};\n//# sourceMappingURL=streamedQuery.js.map","// src/types.ts\nvar dataTagSymbol = Symbol(\"dataTagSymbol\");\nvar dataTagErrorSymbol = Symbol(\"dataTagErrorSymbol\");\nvar unsetMarker = Symbol(\"unsetMarker\");\nexport {\n  dataTagErrorSymbol,\n  dataTagSymbol,\n  unsetMarker\n};\n//# sourceMappingURL=types.js.map","\"use client\";\n\n// src/useQueries.ts\nimport * as React from \"react\";\nimport {\n  QueriesObserver,\n  QueryObserver,\n  noop,\n  notifyManager\n} from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nimport { useIsRestoring } from \"./IsRestoringProvider.js\";\nimport { useQueryErrorResetBoundary } from \"./QueryErrorResetBoundary.js\";\nimport {\n  ensurePreventErrorBoundaryRetry,\n  getHasError,\n  useClearResetErrorBoundary\n} from \"./errorBoundaryUtils.js\";\nimport {\n  ensureSuspenseTimers,\n  fetchOptimistic,\n  shouldSuspend,\n  willFetch\n} from \"./suspense.js\";\nfunction useQueries({\n  queries,\n  ...options\n}, queryClient) {\n  const client = useQueryClient(queryClient);\n  const isRestoring = useIsRestoring();\n  const errorResetBoundary = useQueryErrorResetBoundary();\n  const defaultedQueries = React.useMemo(\n    () => queries.map((opts) => {\n      const defaultedOptions = client.defaultQueryOptions(\n        opts\n      );\n      defaultedOptions._optimisticResults = isRestoring ? \"isRestoring\" : \"optimistic\";\n      return defaultedOptions;\n    }),\n    [queries, client, isRestoring]\n  );\n  defaultedQueries.forEach((query) => {\n    ensureSuspenseTimers(query);\n    ensurePreventErrorBoundaryRetry(query, errorResetBoundary);\n  });\n  useClearResetErrorBoundary(errorResetBoundary);\n  const [observer] = React.useState(\n    () => new QueriesObserver(\n      client,\n      defaultedQueries,\n      options\n    )\n  );\n  const [optimisticResult, getCombinedResult, trackResult] = observer.getOptimisticResult(\n    defaultedQueries,\n    options.combine\n  );\n  const shouldSubscribe = !isRestoring && options.subscribed !== false;\n  React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop,\n      [observer, shouldSubscribe]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  React.useEffect(() => {\n    observer.setQueries(\n      defaultedQueries,\n      options\n    );\n  }, [defaultedQueries, options, observer]);\n  const shouldAtLeastOneSuspend = optimisticResult.some(\n    (result, index) => shouldSuspend(defaultedQueries[index], result)\n  );\n  const suspensePromises = shouldAtLeastOneSuspend ? optimisticResult.flatMap((result, index) => {\n    const opts = defaultedQueries[index];\n    if (opts) {\n      const queryObserver = new QueryObserver(client, opts);\n      if (shouldSuspend(opts, result)) {\n        return fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      } else if (willFetch(result, isRestoring)) {\n        void fetchOptimistic(opts, queryObserver, errorResetBoundary);\n      }\n    }\n    return [];\n  }) : [];\n  if (suspensePromises.length > 0) {\n    throw Promise.all(suspensePromises);\n  }\n  const firstSingleResultWhichShouldThrow = optimisticResult.find(\n    (result, index) => {\n      const query = defaultedQueries[index];\n      return query && getHasError({\n        result,\n        errorResetBoundary,\n        throwOnError: query.throwOnError,\n        query: client.getQueryCache().get(query.queryHash),\n        suspense: query.suspense\n      });\n    }\n  );\n  if (firstSingleResultWhichShouldThrow?.error) {\n    throw firstSingleResultWhichShouldThrow.error;\n  }\n  return getCombinedResult(trackResult());\n}\nexport {\n  useQueries\n};\n//# sourceMappingURL=useQueries.js.map","\"use client\";\n\n// src/useSuspenseQuery.ts\nimport { QueryObserver, skipToken } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseQuery(options, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\"skipToken is not allowed for useSuspenseQuery\");\n    }\n  }\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError,\n      placeholderData: void 0\n    },\n    QueryObserver,\n    queryClient\n  );\n}\nexport {\n  useSuspenseQuery\n};\n//# sourceMappingURL=useSuspenseQuery.js.map","\"use client\";\n\n// src/useSuspenseInfiniteQuery.ts\nimport { InfiniteQueryObserver, skipToken } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseInfiniteQuery(options, queryClient) {\n  if (process.env.NODE_ENV !== \"production\") {\n    if (options.queryFn === skipToken) {\n      console.error(\"skipToken is not allowed for useSuspenseInfiniteQuery\");\n    }\n  }\n  return useBaseQuery(\n    {\n      ...options,\n      enabled: true,\n      suspense: true,\n      throwOnError: defaultThrowOnError\n    },\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nexport {\n  useSuspenseInfiniteQuery\n};\n//# sourceMappingURL=useSuspenseInfiniteQuery.js.map","\"use client\";\n\n// src/useSuspenseQueries.ts\nimport { skipToken } from \"@tanstack/query-core\";\nimport { useQueries } from \"./useQueries.js\";\nimport { defaultThrowOnError } from \"./suspense.js\";\nfunction useSuspenseQueries(options, queryClient) {\n  return useQueries(\n    {\n      ...options,\n      queries: options.queries.map((query) => {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (query.queryFn === skipToken) {\n            console.error(\"skipToken is not allowed for useSuspenseQueries\");\n          }\n        }\n        return {\n          ...query,\n          suspense: true,\n          throwOnError: defaultThrowOnError,\n          enabled: true,\n          placeholderData: void 0\n        };\n      })\n    },\n    queryClient\n  );\n}\nexport {\n  useSuspenseQueries\n};\n//# sourceMappingURL=useSuspenseQueries.js.map","// src/usePrefetchQuery.tsx\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction usePrefetchQuery(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchQuery(options);\n  }\n}\nexport {\n  usePrefetchQuery\n};\n//# sourceMappingURL=usePrefetchQuery.js.map","// src/usePrefetchInfiniteQuery.tsx\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction usePrefetchInfiniteQuery(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  if (!client.getQueryState(options.queryKey)) {\n    client.prefetchInfiniteQuery(options);\n  }\n}\nexport {\n  usePrefetchInfiniteQuery\n};\n//# sourceMappingURL=usePrefetchInfiniteQuery.js.map","// src/queryOptions.ts\nfunction queryOptions(options) {\n  return options;\n}\nexport {\n  queryOptions\n};\n//# sourceMappingURL=queryOptions.js.map","// src/infiniteQueryOptions.ts\nfunction infiniteQueryOptions(options) {\n  return options;\n}\nexport {\n  infiniteQueryOptions\n};\n//# sourceMappingURL=infiniteQueryOptions.js.map","\"use client\";\n\n// src/HydrationBoundary.tsx\nimport * as React from \"react\";\nimport { hydrate } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nvar HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient\n}) => {\n  const client = useQueryClient(queryClient);\n  const optionsRef = React.useRef(options);\n  optionsRef.current = options;\n  const hydrationQueue = React.useMemo(() => {\n    if (state) {\n      if (typeof state !== \"object\") {\n        return;\n      }\n      const queryCache = client.getQueryCache();\n      const queries = state.queries || [];\n      const newQueries = [];\n      const existingQueries = [];\n      for (const dehydratedQuery of queries) {\n        const existingQuery = queryCache.get(dehydratedQuery.queryHash);\n        if (!existingQuery) {\n          newQueries.push(dehydratedQuery);\n        } else {\n          const hydrationIsNewer = dehydratedQuery.state.dataUpdatedAt > existingQuery.state.dataUpdatedAt || dehydratedQuery.promise && existingQuery.state.status !== \"pending\" && existingQuery.state.fetchStatus !== \"fetching\" && dehydratedQuery.dehydratedAt !== void 0 && dehydratedQuery.dehydratedAt > existingQuery.state.dataUpdatedAt;\n          if (hydrationIsNewer) {\n            existingQueries.push(dehydratedQuery);\n          }\n        }\n      }\n      if (newQueries.length > 0) {\n        hydrate(client, { queries: newQueries }, optionsRef.current);\n      }\n      if (existingQueries.length > 0) {\n        return existingQueries;\n      }\n    }\n    return void 0;\n  }, [client, state]);\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current);\n    }\n  }, [client, hydrationQueue]);\n  return children;\n};\nexport {\n  HydrationBoundary\n};\n//# sourceMappingURL=HydrationBoundary.js.map","\"use client\";\n\n// src/useIsFetching.ts\nimport * as React from \"react\";\nimport { notifyManager } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction useIsFetching(filters, queryClient) {\n  const client = useQueryClient(queryClient);\n  const queryCache = client.getQueryCache();\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => queryCache.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [queryCache]\n    ),\n    () => client.isFetching(filters),\n    () => client.isFetching(filters)\n  );\n}\nexport {\n  useIsFetching\n};\n//# sourceMappingURL=useIsFetching.js.map","\"use client\";\n\n// src/useMutationState.ts\nimport * as React from \"react\";\nimport { notifyManager, replaceEqualDeep } from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction useIsMutating(filters, queryClient) {\n  const client = useQueryClient(queryClient);\n  return useMutationState(\n    { filters: { ...filters, status: \"pending\" } },\n    client\n  ).length;\n}\nfunction getResult(mutationCache, options) {\n  return mutationCache.findAll(options.filters).map(\n    (mutation) => options.select ? options.select(mutation) : mutation.state\n  );\n}\nfunction useMutationState(options = {}, queryClient) {\n  const mutationCache = useQueryClient(queryClient).getMutationCache();\n  const optionsRef = React.useRef(options);\n  const result = React.useRef(null);\n  if (!result.current) {\n    result.current = getResult(mutationCache, options);\n  }\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n  return React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => mutationCache.subscribe(() => {\n        const nextResult = replaceEqualDeep(\n          result.current,\n          getResult(mutationCache, optionsRef.current)\n        );\n        if (result.current !== nextResult) {\n          result.current = nextResult;\n          notifyManager.schedule(onStoreChange);\n        }\n      }),\n      [mutationCache]\n    ),\n    () => result.current,\n    () => result.current\n  );\n}\nexport {\n  useIsMutating,\n  useMutationState\n};\n//# sourceMappingURL=useMutationState.js.map","\"use client\";\n\n// src/useMutation.ts\nimport * as React from \"react\";\nimport {\n  MutationObserver,\n  noop,\n  notifyManager,\n  shouldThrowError\n} from \"@tanstack/query-core\";\nimport { useQueryClient } from \"./QueryClientProvider.js\";\nfunction useMutation(options, queryClient) {\n  const client = useQueryClient(queryClient);\n  const [observer] = React.useState(\n    () => new MutationObserver(\n      client,\n      options\n    )\n  );\n  React.useEffect(() => {\n    observer.setOptions(options);\n  }, [observer, options]);\n  const result = React.useSyncExternalStore(\n    React.useCallback(\n      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),\n      [observer]\n    ),\n    () => observer.getCurrentResult(),\n    () => observer.getCurrentResult()\n  );\n  const mutate = React.useCallback(\n    (variables, mutateOptions) => {\n      observer.mutate(variables, mutateOptions).catch(noop);\n    },\n    [observer]\n  );\n  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {\n    throw result.error;\n  }\n  return { ...result, mutate, mutateAsync: result.mutate };\n}\nexport {\n  useMutation\n};\n//# sourceMappingURL=useMutation.js.map","// src/mutationOptions.ts\nfunction mutationOptions(options) {\n  return options;\n}\nexport {\n  mutationOptions\n};\n//# sourceMappingURL=mutationOptions.js.map","\"use client\";\n\n// src/useInfiniteQuery.ts\nimport { InfiniteQueryObserver } from \"@tanstack/query-core\";\nimport { useBaseQuery } from \"./useBaseQuery.js\";\nfunction useInfiniteQuery(options, queryClient) {\n  return useBaseQuery(\n    options,\n    InfiniteQueryObserver,\n    queryClient\n  );\n}\nexport {\n  useInfiniteQuery\n};\n//# sourceMappingURL=useInfiniteQuery.js.map"],"names":["difference","array1","array2","excludeSet","x","replaceAt","array","index","value","copy","QueriesObserver","_a","Subscribable","client","queries","options","__privateAdd","_trackResult","_combineResult","_findMatchingObservers","_onUpdate","_notify","_client","_result","_queries","_options","_observers","_combinedResult","_lastCombine","_lastResult","_observerMatches","__privateSet","__privateGet","observer","result","__privateMethod","onUpdate_fn","notifyManager","prevObservers","newObserverMatches","findMatchingObservers_fn","match","newObservers","newResult","hasIndexChange","notify_fn","combine","matches","r","combineResult_fn","trackResult_fn","observerResult","accessedProp","m","input","replaceEqualDeep","prevObserversMap","observers","defaultedOptions","QueryObserver","previousResult","newTracked","listener","InfiniteQueryObserver","infiniteQueryBehavior","query","state","parentResult","isFetching","isRefetching","isError","isRefetchError","fetchDirection","_b","isFetchNextPageError","isFetchingNextPage","isFetchPreviousPageError","isFetchingPreviousPage","hasNextPage","hasPreviousPage","MutationObserver","_updateResult","_currentResult","_currentMutation","_mutateOptions","updateResult_fn","prevOptions","shallowEqualObjects","hashKey","action","variables","getDefaultState","context","_d","_c","_f","_e","_h","_g","defaultTransformerFn","data","dehydrateMutation","mutation","dehydrateQuery","serializeData","shouldRedactErrors","error","defaultShouldDehydrateMutation","defaultShouldDehydrateQuery","defaultShouldRedactErrors","_","dehydrate","filterMutation","mutations","filterQuery","hydrate","dehydratedState","mutationCache","queryCache","deserializeData","mutationOptions","queryKey","queryHash","meta","promise","dehydratedAt","syncData","tryResolveSync","rawData","existingQueryIsPending","existingQueryIsFetching","hasNewerSyncData","_ignored","serializedState","streamedQuery","queryFn","refetchMode","maxChunks","isRefetch","stream","chunk","prev","addToEnd","dataTagSymbol","dataTagErrorSymbol","unsetMarker","useQueries","queryClient","useQueryClient","isRestoring","useIsRestoring","errorResetBoundary","useQueryErrorResetBoundary","defaultedQueries","React.useMemo","opts","ensureSuspenseTimers","ensurePreventErrorBoundaryRetry","useClearResetErrorBoundary","React.useState","optimisticResult","getCombinedResult","trackResult","shouldSubscribe","React.useSyncExternalStore","React.useCallback","onStoreChange","noop","React.useEffect","suspensePromises","shouldSuspend","queryObserver","fetchOptimistic","willFetch","firstSingleResultWhichShouldThrow","getHasError","useSuspenseQuery","useBaseQuery","defaultThrowOnError","useSuspenseInfiniteQuery","useSuspenseQueries","usePrefetchQuery","usePrefetchInfiniteQuery","queryOptions","infiniteQueryOptions","HydrationBoundary","children","optionsRef","React.useRef","hydrationQueue","newQueries","existingQueries","dehydratedQuery","existingQuery","useIsFetching","filters","useIsMutating","useMutationState","getResult","nextResult","useMutation","mutate","mutateOptions","shouldThrowError","useInfiniteQuery"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}